#math 모듈은 인수가 실수 (스칼라) 에 대해서만 적용
#cmath 모듈은 복소수 (스칼라) 인 경우에만 적용
#만약 행렬 연산이 필요하다면 이 두 모듈은 사용할 수 없으며 numpy 를 사용해야 한다. 
#이 모듈은 파이썬의 고급 연산 분야의 기본 모듈로서 벡터 혹은 행렬에 대한 요소간 
#연산을 지원하므로 가장 적용 범위가 넓다.

import numpy as np
import math

print(math.sqrt(2))
print(np.sqrt(2))

#============================================
##list vs np.array() 
#============================================

ls =[1, 2, 3]
# converting the list into a Numpy array


ls + 4 
arr + 4 

## np.dot/ np.cross
a=np.array([1,2,3])
b=np.array([3,4,5])


## 예제 1: 함수 그래프 그리기 =======================
import numpy as np



print('g(f(2))=', g(f(2)))
print('f(g(2))=', f(g(2)))


#======================================================

## 예제 2: 로그함수/ 삼각함수 그리기  =======================



## 예제 3: 함수 그래프 그리기 =======================


def f(x):
  if x>=-1 and x<1:
    return -x**2+2
  if x>=1 and x<=3:
    return x**2-4*x+3
  if x>3 and x<=5:
    return -x**2 + 8*x-14



# fx 초기화 및 fx 값을 계산


#======================================================


## 예제 4: 정규확률밀도함수 그리기 =======================



## 예제 5: 함수의 미분 ===============================
# forward difference: D_{+}f = (f(a+h)-f(a))/h 
# backward difference: D_{-}f = (f(a)-f(a+h))/h
# central difference: D_{0}f = (f(a+h)-f(a+h))/(2*h)


## 예제 6: 함수의 적분 ===============================
# Simpson's rule: [a,b] 구간을 n등분한 뒤, 각 구간을 2차 함수로 근사한 후, 2차 함수의 넓이를 더해 적분함
# int_a^b f(x) dx = 1/3*h*[f(0)+2*sigma_{i=1}^{n/2-1}f(x_{2i}) +4*sigma_{i=1}^{n/2}f(x_{2i-1})+f(x_n)]
